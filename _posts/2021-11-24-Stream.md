---
layout: single
title: "Stream 에 대한 정리"
---

Java 버전을 정리하면서 Stream가 자주 보였고 가끔 코딩 문제 풀 때 사용하는 사람들을 봤지만 잘 몰랐기에 자세히 알고 싶어서 조사하게 되었다.

<br/>
<br/>

# 스트림이란?

Java 8에서 추가된 Stream은 람다를 활용할 수 있는 기술 중 하나이다. 이전에는 배열 또는 Collection를 다루는 방법이 for 와 foreach 문을 돌면서 요소를 하나씩 꺼내서 다루는 방법을 사용했다. 하지만 복잡해질수록 코드의 양이 많아지고 로직이 섞이며 불편함을 겪었다.

한마디로 스트림은 `데이터의 흐름`이라고 말할 수 있다. 배열 or 컬렉션 인스턴스에 함수 여러 개를 조합해서 원하는 결과를 필터링해서 얻을 수 있고 람다를 사용해서 코드를 좀 더 간결하게 표현할 수 있다.

크게 세 가지로 나눌 수 있다.
+ 생성하기 - 스트림 인스턴스 생성
+ 가공하기 - 필터링, 맵핑 등 원하는 결과를 만들어가는 중간 작업
+ 결과 만들기 - 최종적으로 결과를 만들어내는 작업


<br/>

### 스트림 생성하기

스트림을 만드는 방법은 다양하다.


 - 배열 스트림

배열은 다음과 같이 Arrays.stream 메소드를 사용한다. 

```java
//Arrays Stream
String[] arr = new String[] {"a","b","c"};
Stream<String> stream = Arrays.stream(arr);
Stream<String> streamOfArrayPart = Arrays.stream(arr, 1, 3)// 인덱스 1~2까지  즉 [b, c]
```
<br/>
<br/>

 - 컬렉션 스트림
 
 컬렉션 타입(Collection, List, Set)의 경우 인터페이스에 추가된 디폴트 메소드 stream 을 이용해서 스트림을 만들 수 있다.
 
```java
//Collection Stream
public interface Collection<E> extends Iterable<E>{
  default Stream<E> stream(){
    return StreamSupport.stream(spliterator(), false);
  }
}
```
<br/>
<br/>


- 비어있는 스트림

비어있는 스트림도 생성 가능하다. 빈 스트림은 요소가 없을 때 null 대신 사용할 수 있다.

```java
public Stream<String> streamOf(List<String> list){
  return list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
```

<br/>
<br/>


- Stream.builder()

빌더를 사용하면 스트림에 직접적으로 원하는 값을 넣을 수 있다. 마지막에 `build` 메소드로 스트림을 리턴한다.

```java
Stream<String> builderStream = stream.<String>builder()
        .add("짬뽕").add("짜장면").add("탕수육")
        .build(); // [짬뽕,짜장면,탕수육]
```

<br/>
<br/>

- Stream.generate()

`generate` 메소드를 이용하면 `Supplier<T>` 에 해당하는 람다로 값을 넣을 수 있다.
  
  > Supplier<T> 는 인자는 없고 리턴 값만 있는 함수형 인터페이스

  ```java
  //함수 형태
  public static<T> Stream<T> generate(Supplier<T> s){} 
  ```
  이때 생성되는 스트림은 크기가 정해져 있지 않으므로 특정 사이즈로 최대 크기를 제한해야 한다.
  
  ```java
  Stream<String> generatedStream =
    Stream.generate( ( ) -> "gang" ).limit(3); // [gang,gang,gang]
  ```

<br/>
<br/>
  
  - Stream.iterate()
  
  `iterate` 메소드를 이용하면 초깃값과 해당 값을 다루는 람다를 이용해서 스트림에 들어갈 요소를 정할 수 있다.
  
  ```java
  //[30, 32, 34, 36, 38]
  Stream<Integer> iteratedStream =
      Stream.iterate(30, n-> n+2).limit(5);
  ```
  
  
<br/>
<br/>
  
  - 기본 타입형 스트림
  
  제네릭을 사용하지 않고 직접적으로 해당 타입의 스트림을 만들 수 있다.
  `range` 메소드와 `rangeClosed`메소드의 차이는 종료지점이 포함되는지의 여부 차이이다.
  
  ```java
  IntStream intStream = IntStream.range(1,5); // [1, 2, 3, 4]
  LongStream longStream = LongStream.rangeClosed(1,5); // [1, 2, 3, 4, 5]
  ```
  
  제네릭이 사용되지 않기에 불필요한 오토박싱이 일어나지 않지만 필요한 경우 `boxed` 메소드를 이용해서 박싱을 할 수 있다.
  
  ```java
  Stream<Integer> boxedIntStream = IntStream.range(1,5).boxed();
  ```
  
  > boxed() 메소드는 int, long, double 요소를 Integer, Long, Double 요소로 박싱 해서 Stream을 생성한다.

  
<br/>
<br/>
  
  - 문자열 스트링
  
  스트링을 이용해서 스트림을 생성 가능하다. 
  
  ```java
  //각 문자를 IntStream으로 변환한 예
  //[83, 116, 114, 101, 97, 109]
  IntStream charsStream = "Stream".chars();
  ```
  
  정규 표현식을 이용해서 문자열을 자르고, 각 요소들로 스트림을 만들 수도 있다.
  
  ```java
  // [짬뽕, 짜장면, 탕수육]
  Stream<String> stringStream =
      Pattern.compile(", ").splitAsStream("짬뽕, 짜장면, 탕수육");
  ```
  
<br/>
<br/>
  
  
  - 스트림 연결하기
  
  `Stream.concat` 메소드를 이용해 두 개의 스트림을 연결해서 새로운 스트림을 만들 수 있다.
  
  ```java
  //[사과, 딸기, 수박, 참외, 메론, 배]
  Stream<String> stream1 = Stream.of("사과","딸기","수박");
  Stream<String> stream2 = Stream.of("참외","메론","배");
  Stream<String> concat = Stream.concat(stream1,stream2);
  ```

<br/>
<br/>
  
  
### 스트림 가공하기
  
  
  
